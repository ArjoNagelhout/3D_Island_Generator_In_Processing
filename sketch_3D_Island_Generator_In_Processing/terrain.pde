// This is the terrain class
/*

It stores a PShape group, which has strips as its children. 
This is because in processing you can't create a grid using vertexes, only QUAD_STRIPs

It uses multiple layers of Perlin noise, 
for which I created a class to allow for noise at specific heights, generated by earlier noise layers

It stores a 2d array of y values so that this can be used in other parts of the program.
It also has a method that helps getting the y value from a given x, z coordinate

*/

class Terrain {
  PShape terrain;
  PShape[] strips;

  float w, h;
  float scale;
  int columns, rows;
  
  float[][] yValues;

  Noise[] noise;

  Terrain(int w, int h, int scale, Noise[] noise) {

    this.w = w;
    this.h = h;
    this.scale = scale;
    this.noise = noise;
    
    
    
    generate_terrain();
  }
  
  float XZtoY(float x, float z) {
    
    int c = int((x+worldSize/2) / scale);
    int r = int((z+worldSize/2) / scale);
    
    return yValues[r][c];
  }

  float get_y(float c, float r) {
    float y = 0;

    for (Noise n : noise) {
      float noise_y = map(noise(c * n.scale, r * n.scale), 0, 1, n.min, n.max);
      float multiplier = (1/n.falloff)*-(abs(y+n.h))+1;
      if (multiplier < 0) {
        multiplier = 0;
      }
      y -= noise_y * multiplier;
      
    }
    
    float distance_to_center = dist((float)columns/2, (float)rows/2, c , r);
    
    y+= -1000 + 10* distance_to_center;
    
    yValues[(int)r][(int)c] = y;

    return y;
  }

  void render() {

    shape(terrain);
  }

  void generate_terrain() {
    columns = int(w / scale);
    rows = int(h / scale);
    
    yValues = new float[rows+1][columns+1];

    strips = new PShape[rows];
    noStroke();
    //fill(#61948b);
    terrain = createShape(GROUP);

    for (int r = 0; r < rows; r++) {

      strips[r] = createShape();
      strips[r].beginShape(TRIANGLE_STRIP);

      

      for (int c = 0; c < columns+1; c++) {
        strips[r].vertex(c * scale, get_y(c, r), r * scale, textureSize*((c * scale)/w), textureSize*((r * scale)/w));
        strips[r].vertex(c * scale, get_y(c, r+1), (r + 1) * scale, textureSize*((c * scale)/w), textureSize*(((r + 1) * scale)/w));
      }

      strips[r].endShape();
      terrain.addChild(strips[r]);
    }
  }
}

class Noise {
  int min;
  int max;
  float scale;
  int h; // Height at which the noise has to appear
  float falloff; // How quickly the noise dissapears when the height is more or less than "h"

  Noise(int min, int max, float scale, int h, float falloff) {
    this.min = min;
    this.max = max;
    this.scale = scale;
    this.h = h;
    this.falloff = falloff;
  }
}
